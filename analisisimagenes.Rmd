---
title: "AnalisisImagenes"
output: html_document
date: "2025-12-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(jpeg)
library(class)
library(caret)

# Definir la ruta base
ruta_base_imagenes <- "images"

# lectura de las imagenes de noche
ruta_noche <- file.path(ruta_base_imagenes, "0")
archivos_noche <- list.files(
  path = ruta_noche,
  pattern = "\\.jpe?g$",
  full.names = TRUE,
  recursive = FALSE
)

df_noche <- data.frame(
  ruta = archivos_noche,
  etiqueta = 0 # Noche
)


# Leer y etiquetar imágenes del subdirectorio "1" (Día)

ruta_dia <- file.path(ruta_base_imagenes, "1")
archivos_dia <- list.files(
  path = ruta_dia,
  pattern = "\\.jpe?g$",
  full.names = TRUE,
  recursive = FALSE
)

df_dia <- data.frame(
  ruta = archivos_dia,
  etiqueta = 1 # Día
)

# lectura de las imagenes de día

datos_imagenes <- rbind(df_noche, df_dia)


set.seed(42) 

indices_entrenamiento <- createDataPartition(
  y = datos_imagenes$etiqueta,
  p = 0.8,
  list = FALSE 
)

# Crear los conjuntos de datos de TRAIN y TEST
datos_train <- datos_imagenes[indices_entrenamiento, ]
datos_test <- datos_imagenes[-indices_entrenamiento, ]


```

```{r}
extraer_rgb <- function(df_datos) {
  
  # Matriz para R, G, B
  features <- matrix(0, nrow = nrow(df_datos), ncol = 3)
  colnames(features) <- c("R_mediana", "G_mediana", "B_mediana")
  
  cat("Extrayendo RGB de", nrow(df_datos), "imágenes...\n")
  
  for (j in 1:nrow(df_datos)) {
    tryCatch({
      img <- readJPEG(df_datos$ruta[j])
      
      # Si la imagen es escala de grises (matriz 2D), replicar canales
      if (length(dim(img)) == 2) {
        r <- img; g <- img; b <- img
      } else {
        # Si es color (matriz 3D)
        r <- img[,,1]
        g <- img[,,2]
        b <- img[,,3]
      }
      
      features[j, 1] = median(r)
      features[j, 2] = median(g)
      features[j, 3] = median(b)
      
    }, error = function(e) {
      cat("Error leyendo:", df_datos$ruta[j], "\n")
    })
  }
  
  # Unir al dataframe y asegurar que la etiqueta es factor
  df_final <- cbind(df_datos, features)
  df_final$etiqueta <- as.factor(df_final$etiqueta)
  
  return(df_final)
}

# Aplicamos la función 
datos_train <- extraer_rgb(datos_train)
datos_test <- extraer_rgb(datos_test)

print(head(datos_train))



```
```{r}
#Preprocesamiento de imagenes
#misma resolucion y rango de valores



```


```{r}
library(ggplot2)
library(tidyr)

# Transformar datos a formato largo para plotear 
datos_long <- pivot_longer(datos_train, cols = c("R_mediana", "G_mediana", "B_mediana"), 
                           names_to = "Feature", values_to = "Valor")

# Plot de Cajas: Compara la distribución de cada canal por etiqueta
ggplot(datos_long, aes(x = Feature, y = Valor, fill = etiqueta)) +
  geom_boxplot() +
  scale_fill_manual(values = c("red", "skyblue"), labels = c("Noche", "Día")) +
  labs(title = "Separación de Clases usando RGB",
       subtitle = "Si las cajas no se tocan, el clasificador será muy bueno",
       y = "Intensidad Mediana (0-1)") +
  theme_minimal()
```
Para la etiqueta "1" (Día), las cajas de R, G y B están mucho más altas (cerca de 0.5 - 1.0) y para "0" (Noche) están muy bajas (cerca de 0.0 - 0.2).

```{r}
#plotear en 3D las caracteristicas RGB medianos, con cada punto segun su etiqueta
library(plotly)
fig <- plot_ly(
  data = datos_train,
  x = ~R_mediana,
  y = ~G_mediana,
  z = ~B_mediana,
  color = ~as.factor(etiqueta),
  colors = c('blue', 'yellow'),
  type = 'scatter3d',
  mode = 'markers'
)
fig <- fig %>% layout(
  scene = list(
    xaxis = list(title = 'R Mediana'),
    yaxis = list(title = 'G Mediana'),
    zaxis = list(title = 'B Mediana')
  ),
  title = 'Distribución de Imágenes por Características RGB Medianas'
)
fig
```
Probamos a entrenar clasificador KNN 
Usamos solo R, G y B.
```{r}
# Seleccionar solo columnas numéricas RGB
cols_rgb <- c("R_mediana", "G_mediana", "B_mediana")

train_x <- datos_train[, cols_rgb]
test_x <- datos_test[, cols_rgb]
train_y <- datos_train$etiqueta
test_y <- datos_test$etiqueta

# Entrenar Random Forest
set.seed(42)
predicciones_rgb <- 

# Matriz de Confusión
cm <- confusionMatrix(predicciones_rgb, test_y)
print(cm)

# Ver Accuracy 
cat("Precisión del modelo solo con RGB:", cm$overall['Accuracy'] * 100, "%\n")
```
Probamos con otro dataset para test ver si las clasifica correctamente
```{r}
# Cargar nuevo dataset de prueba
ruta_base_nuevo <- "imagenes/nighttime"
archivos_nuevo <- list.files(
  path = ruta_base_nuevo,
  pattern = "\\.jpe?g$",
  full.names = TRUE,
  recursive = FALSE
)

# Agregamos etiqueta = 0 ya que todas las imagenes son de noche
df_nuevo <- data.frame(
  ruta = archivos_nuevo,
  etiqueta = 0 
)

datos_nuevo <- extraer_rgb(df_nuevo)

# Seleccionar solo columnas numéricas RGB
cols_rgb <- c("R_mediana", "G_mediana", "B_mediana")
nuevo_x <- datos_nuevo[, cols_rgb]

# Predecir etiquetas con el modelo KNN entrenado
predicciones_nuevo <- knn(train = train_x, test = nuevo_x, cl = train_y, k = 5)

# Mostrar predicciones
datos_nuevo$prediccion <- predicciones_nuevo

# Matriz de confusión
# Nota: Asegúrate de que los niveles de factor sean iguales (0 y 1)
etiquetas_verdaderas_nuevo <- factor(datos_nuevo$etiqueta, levels = c(0, 1))
cm_nuevo <- confusionMatrix(predicciones_nuevo, etiquetas_verdaderas_nuevo)

print(cm_nuevo)
cat("Precisión del modelo en el nuevo dataset:", cm_nuevo$overall['Accuracy'] * 100, "%\n")


```

