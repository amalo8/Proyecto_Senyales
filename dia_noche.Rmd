---
title: "AnalisisImagenes"
output: html_document
date: "2025-12-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

```{r}
library(jpeg)
library(class)
library(caret)
library(randomForest)

# Definir la ruta base
ruta_base_imagenes <- "imagenes/daynight"

# lectura de las imagenes de noche
ruta_noche <- file.path(ruta_base_imagenes, "nighttime")
archivos_noche <- list.files(
  path = ruta_noche,
  pattern = "\\.jpe?g$",
  full.names = TRUE,
  recursive = FALSE
)

df_noche <- data.frame(
  ruta = archivos_noche,
  etiqueta = 0 # Noche
)


# Leer y etiquetar imágenes del subdirectorio dia

ruta_dia <- file.path(ruta_base_imagenes, "daytime")
archivos_dia <- list.files(
  path = ruta_dia,
  pattern = "\\.jpe?g$",
  full.names = TRUE,
  recursive = FALSE
)

df_dia <- data.frame(
  ruta = archivos_dia,
  etiqueta = 1 # Día
)

# lectura de las imagenes de día

datos_imagenes <- rbind(df_noche, df_dia)


set.seed(42) 

indices_entrenamiento <- createDataPartition(
  y = datos_imagenes$etiqueta,
  p = 0.8,
  list = FALSE 
)

# Crear los conjuntos de datos de TRAIN y TEST
datos_train <- datos_imagenes[indices_entrenamiento, ]
datos_test <- datos_imagenes[-indices_entrenamiento, ]


```

```{r}
extraer_rgb <- function(df_datos) {
  
  # Matriz para R, G, B
  features <- matrix(0, nrow = nrow(df_datos), ncol = 3)
  colnames(features) <- c("R_mediana", "G_mediana", "B_mediana")
  
  cat("Extrayendo RGB de", nrow(df_datos), "imágenes...\n")
  
  for (j in 1:nrow(df_datos)) {
    tryCatch({
      img <- readJPEG(df_datos$ruta[j])
      
      # Si la imagen es escala de grises (matriz 2D), replicar canales
      if (length(dim(img)) == 2) {
        r <- img; g <- img; b <- img
      } else {
        # Si es color (matriz 3D)
        r <- img[,,1]
        g <- img[,,2]
        b <- img[,,3]
      }
      
      features[j, 1] = median(r)
      features[j, 2] = median(g)
      features[j, 3] = median(b)
      
      
    }, error = function(e) {
      cat("Error leyendo:", df_datos$ruta[j], "\n")
    })
  }
  
  # Unir al dataframe y asegurar que la etiqueta es factor
  df_final <- cbind(df_datos, features)
  df_final$etiqueta <- as.factor(df_final$etiqueta)
  
  return(df_final)
}

# Aplicamos la función 
datos_train <- extraer_rgb(datos_train)
datos_test <- extraer_rgb(datos_test)

print(head(datos_train))



```

```{r}
#Preprocesamiento de imagenes
#misma resolucion y rango de valores



```


```{r}
library(ggplot2)
library(tidyr)

# Transformar datos a formato largo para plotear 
datos_long <- pivot_longer(datos_train, cols = c("R_mediana", "G_mediana", "B_mediana"), 
                           names_to = "Feature", values_to = "Valor")

# Plot de Cajas: Compara la distribución de cada canal por etiqueta
ggplot(datos_long, aes(x = Feature, y = Valor, fill = etiqueta)) +
  geom_boxplot() +
  scale_fill_manual(values = c("red", "skyblue"), labels = c("Noche", "Día")) +
  labs(title = "Separación de Clases usando RGB",
       subtitle = "Si las cajas no se tocan, el clasificador será muy bueno",
       y = "Intensidad Mediana (0-1)") +
  theme_minimal()
```
Para la etiqueta "1" (Día), las cajas de R, G y B están mucho más altas (cerca de 0.5 - 1.0) y para "0" (Noche) están muy bajas (cerca de 0.0 - 0.2).

```{r}
#plotear en 3D las caracteristicas RGB medianos, con cada punto segun su etiqueta
library(plotly)
fig <- plot_ly(
  data = datos_train,
  x = ~R_mediana,
  y = ~G_mediana,
  z = ~B_mediana,
  color = ~as.factor(etiqueta),
  colors = c('blue', 'yellow'),
  type = 'scatter3d',
  mode = 'markers'
)
fig <- fig %>% layout(
  scene = list(
    xaxis = list(title = 'R Mediana'),
    yaxis = list(title = 'G Mediana'),
    zaxis = list(title = 'B Mediana')
  ),
  title = 'Distribución de Imágenes por Características RGB Medianas'
)
fig
```
Probamos a entrenar clasificador KNN 
Usamos solo R, G y B.
```{r}
# Seleccionar solo columnas numéricas RGB
cols_rgb <- c("R_mediana", "G_mediana", "B_mediana")

train_x <- datos_train[, cols_rgb]
test_x <- datos_test[, cols_rgb]
train_y <- datos_train$etiqueta
test_y <- datos_test$etiqueta

# Entrenar Random Forest
set.seed(42)
rf_model <- randomForest(x = train_x, y = train_y, ntree = 100)
# Predecir en el conjunto de prueba
predicciones_rf <- predict(rf_model, newdata = test_x)
# Matriz de confusión
cm_rf <- confusionMatrix(predicciones_rf, test_y)
print(cm_rf)
cat("Precisión del modelo Random Forest:", cm_rf$overall['Accuracy'] * 100, "%\n")

```

```{r}
# Probar a extraer caracteristicas del espacio HSV
library(grDevices)
rgb_a_hsv <- function(r, g, b) {
  rgb_matrix <- matrix(c(r, g, b), ncol = 3)
  hsv_matrix <- rgb2hsv(t(rgb_matrix),maxColorValue = 1) #porque los valores ya estan entre 0 y 1
  return(t(hsv_matrix))
}
# Función para extraer características HSV medianas
extraer_hsv <- function(df_datos) {
  features <- matrix(0, nrow = nrow(df_datos), ncol = 3)
  colnames(features) <- c("H_mediana", "S_mediana", "V_mediana")
  
  cat("Extrayendo HSV de", nrow(df_datos), "imágenes...\n")
  
  for (j in 1:nrow(df_datos)) {
    tryCatch({
      img <- readJPEG(df_datos$ruta[j])
      
      if (length(dim(img)) == 2) {
        r <- img; g <- img; b <- img
      } else {
        r <- img[,,1]
        g <- img[,,2]
        b <- img[,,3]
      }
      
      hsv_vals <- rgb_a_hsv(as.vector(r), as.vector(g), as.vector(b))
      
      features[j, 1] = median(hsv_vals[, 1])
      features[j, 2] = median(hsv_vals[, 2])
      features[j, 3] = median(hsv_vals[, 3])

      
    }, error = function(e) {
      cat("Error leyendo:", df_datos$ruta[j], "\n")
    })
  }
  
  df_final <- cbind(df_datos, features)
  df_final$etiqueta <- as.factor(df_final$etiqueta)
  
  return(df_final)
}

# Aplicar la función a los conjuntos de datos
datos_train_hsv <- extraer_hsv(datos_train)
datos_test_hsv <- extraer_hsv(datos_test)
# Seleccionar solo columnas numéricas HSV
cols_hsv <- c("H_mediana", "S_mediana", "V_mediana")
train_x_hsv <- datos_train_hsv[, cols_hsv]
test_x_hsv <- datos_test_hsv[, cols_hsv]
train_y_hsv <- datos_train_hsv$etiqueta
test_y_hsv <- datos_test_hsv$etiqueta
```

```{r}

#Mostrar boxplots de las caracteristicas HSV
datos_long_hsv <- pivot_longer(datos_train_hsv, cols = c("H_mediana", "S_mediana", "V_mediana"), 
                           names_to = "Feature", values_to = "Valor")
ggplot(datos_long_hsv, aes(x = Feature, y = Valor, fill = etiqueta)) +
  geom_boxplot() +
  scale_fill_manual(values = c("red", "skyblue"), labels = c("Noche", "Día")) +
  labs(title = "Separación de Clases usando HSV",
       subtitle = "Si las cajas no se tocan, el clasificador será muy bueno",
       y = "Valor Mediano (0-1)") +
  theme_minimal()
```

```{r}
#plotear en 3D las caracteristicas HSV medianos, con cada punto segun su etiqueta
library(plotly)
fig_hsv <- plot_ly(
  data = datos_train_hsv,
  x = ~H_mediana,
  y = ~S_mediana,
  z = ~V_mediana,
  color = ~as.factor(etiqueta),
  colors = c('blue', 'yellow'),
  type = 'scatter3d',
  mode = 'markers'
)
fig_hsv <- fig_hsv %>% layout(
  scene = list(
    xaxis = list(title = 'H Mediana'),
    yaxis = list(title = 'S Mediana'),
    zaxis = list(title = 'V Mediana')
  ),
  title = 'Distribución de Imágenes por Características HSV Medianas'
)
fig_hsv
```





```{r}
# Entrenar Random Forest con características HSV

set.seed(42)
rf_model_hsv <- randomForest(x = train_x_hsv, y = train_y_hsv, ntree = 100)
# Predecir en el conjunto de prueba
predicciones_rf_hsv <- predict(rf_model_hsv, newdata = test_x_hsv)
# Matriz de confusión
cm_rf_hsv <- confusionMatrix(predicciones_rf_hsv, test_y_hsv)
print(cm_rf_hsv)
cat("Precisión del modelo Random Forest con HSV:", cm_rf_hsv$overall['Accuracy'] * 100, "%\n")
```
```{r}
#Entrenar con todas las caracteristicas RGB + HSV
train_x_todas <- datos_train_hsv[, c("R_mediana", "G_mediana", "B_mediana", "H_mediana", "S_mediana", "V_mediana")]
test_x_todas <- datos_test_hsv[, c("R_mediana", "G_mediana", "B_mediana", "H_mediana", "S_mediana", "V_mediana")]
train_y_todas <- datos_train_hsv$etiqueta
test_y_todas <- datos_test_hsv$etiqueta

set.seed(42)
rf_model_todas <- randomForest(x = train_x_todas, y = train_y_todas, ntree = 100)
# Predecir en el conjunto de prueba
predicciones_rf_todas <- predict(rf_model_todas, newdata = test_x_todas)
# Matriz de confusión
cm_rf_todas <- confusionMatrix(predicciones_rf_todas, test_y_todas)
print(cm_rf_todas)
cat("Precisión del modelo Random Forest con todas las características:", cm_rf_todas$overall['Accuracy'] * 100, "%\n")
```

Añadimos nueva característica: desviación estándar del canal V. Esta característica puede capturar la variabilidad de brillo en la imagen, lo que podría ser útil para distinguir entre imágenes diurnas y nocturnas.
```{r}
# nueva caracteristica: desviacion estandar de V
extraer_sd_V <- function(df_datos) {
  features <- numeric(nrow(df_datos))
  for (j in 1:nrow(df_datos)) {
    tryCatch({
      img <- readJPEG(df_datos$ruta[j])
      if (length(dim(img)) == 3) {
        r <- img[,,1]
        g <- img[,,2]
        b <- img[,,3]
        hsv_vals <- rgb_a_hsv(as.vector(r), as.vector(g), as.vector(b))
        V_channel <- matrix(hsv_vals[, 3], nrow = nrow(r), ncol = ncol(r))
      } else {
        V_channel <- img
      }
      features[j] <- sd(as.vector(V_channel))
    }, error = function(e) {
      cat("Error leyendo:", df_datos$ruta[j], "\n")
    })
  }
  df_final <- cbind(df_datos, SD_V = features)
  df_final$etiqueta <- as.factor(df_final$etiqueta)
  return(df_final)
}
```

```{r}
# Aplicar la función a los conjuntos de datos
datos_train_sd <- extraer_sd_V(datos_train_hsv)
datos_test_sd <- extraer_sd_V(datos_test_hsv)
```

```{r}
#entrenar modelo con todas las caracteristicas + SD de V
train_x_sd <- datos_train_sd[, c("R_mediana", "G_mediana", "B_mediana", "H_mediana", "S_mediana", "V_mediana","SD_V")]
test_x_sd <- datos_test_sd[, c("R_mediana", "G_mediana", "B_mediana", "H_mediana", "S_mediana", "V_mediana",  "SD_V")]
train_y_sd <- datos_train_sd$etiqueta
test_y_sd <- datos_test_sd$etiqueta

set.seed(42)
rf_model_sd <- randomForest(x = train_x_sd, y = train_y_sd, ntree = 100)
# Predecir en el conjunto de prueba
predicciones_rf_sd <- predict(rf_model_sd, newdata = test_x_sd)
# Matriz de confusión
cm_rf_sd <- confusionMatrix(predicciones_rf_sd, test_y_sd)
print(cm_rf_sd)
cat("Precisión del modelo Random Forest con todas las características + SD de V:", cm_rf_sd$overall['Accuracy'] * 100, "%\n")

importancia_sd <- importance(rf_model_sd)
print(importancia_sd)
```

```{r}
#sacar imagenes mal clasificadas
mal_clasificadas <- datos_test_sd[predicciones_rf_todas != test_y_todas, "ruta"]
print("Número de imágenes mal clasificadas:")
length(mal_clasificadas)
#hacemos un bucle con subplots para mostrar las imagenes mal clasificadas
#hay 23 imagenes
library(magick)
imgs <- image_read(mal_clasificadas)
grid_imagenes <- image_montage(imgs, 
                               tile = "5x5", 
                               geometry = "x200+10+10", # Tamaño + márgenes
                               shadow = TRUE)
print(grid_imagenes)
```
